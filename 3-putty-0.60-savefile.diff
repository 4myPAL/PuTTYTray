=== cmdline.c
==================================================================
--- cmdline.c	(revision 7489)
+++ cmdline.c	(local)
@@ -162,6 +162,18 @@
 	loaded_session = TRUE;
 	return 2;
     }
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Load file based session from commandline
+	 */
+	if (!strcmp(p, "-loadfile") || !strcmp(p, "-file") || !strcmp(p, "-fileload")) {
+	RETURN(2);
+	do_defaults_file(value, cfg);
+	loaded_session = TRUE;
+	return 2;
+	}
+
     if (!strcmp(p, "-ssh")) {
 	RETURN(1);
 	UNAVAILABLE_IN(TOOLTYPE_FILETRANSFER | TOOLTYPE_NONNETWORK);
=== config.c
==================================================================
--- config.c	(revision 7489)
+++ config.c	(local)
@@ -507,8 +507,13 @@
                     sfree(errmsg);
                 }
             }
-	    get_sesslist(&ssd->sesslist, FALSE);
-	    get_sesslist(&ssd->sesslist, TRUE);
+		/*
+		 * HACK: PuttyTray / PuTTY File
+		 * Added storagetype to get_sesslist
+		 */
+	    get_sesslist(&ssd->sesslist, FALSE, cfg->session_storagetype);
+	    get_sesslist(&ssd->sesslist, TRUE, cfg->session_storagetype);
+
 	    dlg_refresh(ssd->editbox, dlg);
 	    dlg_refresh(ssd->listbox, dlg);
 	} else if (!ssd->midsession &&
@@ -518,8 +523,14 @@
 		dlg_beep(dlg);
 	    } else {
 		del_settings(ssd->sesslist.sessions[i]);
-		get_sesslist(&ssd->sesslist, FALSE);
-		get_sesslist(&ssd->sesslist, TRUE);
+
+		/*
+		 * HACK: PuttyTray / PuTTY File
+		 * Added storagetype to get_sesslist
+		 */
+		get_sesslist(&ssd->sesslist, FALSE, cfg->session_storagetype);
+		get_sesslist(&ssd->sesslist, TRUE, cfg->session_storagetype);
+
 		dlg_refresh(ssd->listbox, dlg);
 	    }
 	} else if (ctrl == ssd->okbutton) {
@@ -568,6 +579,51 @@
     }
 }
 
+/*
+ * HACK: PuttyTray / PuTTY File
+ * Storagetype radio buttons event handler
+ */
+void storagetype_handler(union control *ctrl, void *dlg, void *data, int event)
+{
+    int button;
+    struct sessionsaver_data *ssd =(struct sessionsaver_data *)ctrl->generic.context.p;
+	Config *cfg = (Config *)data;
+
+    /*
+     * For a standard radio button set, the context parameter gives
+     * offsetof(targetfield, Config), and the extra data per button
+     * gives the value the target field should take if that button
+     * is the one selected.
+     */
+    if (event == EVENT_REFRESH) {
+		button = cfg->session_storagetype; // Button index = same as storagetype number. Set according to config
+		dlg_radiobutton_set(ctrl, dlg, button);
+	} else if (event == EVENT_VALCHANGE) {
+		button = dlg_radiobutton_get(ctrl, dlg);
+
+		// Switch between registry and file
+		if (ctrl->radio.buttondata[button].i == 0) {
+			get_sesslist(&ssd->sesslist, FALSE, 0);
+			get_sesslist(&ssd->sesslist, TRUE, 0);
+			dlg_refresh(ssd->editbox, dlg);
+			dlg_refresh(ssd->listbox, dlg);
+
+			// Save setting into config (the whole *(int *)ATOFFSET(data, ctrl->radio.context.i) = ctrl->radio.buttondata[button].i; didn't work)
+			// and I don't see why I shouldn't do it this way (it works?)
+			cfg->session_storagetype = 0;
+		} else {
+			get_sesslist(&ssd->sesslist, FALSE, 1);
+			get_sesslist(&ssd->sesslist, TRUE, 1);
+			dlg_refresh(ssd->editbox, dlg);
+			dlg_refresh(ssd->listbox, dlg);
+
+			// Here as well
+			cfg->session_storagetype = 1;
+		}
+	}
+}
+/** HACK: END **/
+
 struct charclass_data {
     union control *listbox, *editbox, *button;
 };
@@ -1102,7 +1158,7 @@
 }
 
 void setup_config_box(struct controlbox *b, int midsession,
-		      int protocol, int protcfginfo)
+		      int protocol, int protcfginfo, int session_storagetype) // HACK: PuttyTray / PuTTY File - Added 'int session_storagetype'
 {
     struct controlset *s;
     struct sessionsaver_data *ssd;
@@ -1113,6 +1169,7 @@
     struct portfwd_data *pfd;
     union control *c;
     char *str;
+	int current_storagetype; // HACK: PuttyTray / PuTTY File - stores storagetype after sess_list may or may not have switched between file/registry because registry is empty
 
     ssd = (struct sessionsaver_data *)
 	ctrl_alloc(b, sizeof(struct sessionsaver_data));
@@ -1192,7 +1249,7 @@
 		    midsession ? "Save the current session settings" :
 		    "Load, save or delete a stored session");
     ctrl_columns(s, 2, 75, 25);
-    get_sesslist(&ssd->sesslist, TRUE);
+    current_storagetype = get_sesslist(&ssd->sesslist, TRUE, (midsession ? session_storagetype : (session_storagetype + 2))); // HACK: PuttyTray / PuTTY File - The +2 triggers storagetype autoswitching
     ssd->editbox = ctrl_editbox(s, "Saved Sessions", 'e', 100,
 				HELPCTX(session_saved),
 				sessionsaver_handler, P(ssd), P(NULL));
@@ -1234,6 +1291,28 @@
     }
     ctrl_columns(s, 1, 100);
 
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Add radio buttons
+	 *
+     * Couldn't get the default selection to switch, so I switched the button position instead.
+	 * Must be the lamest solution I ever came up with.
+	 *
+	 * In midsession, changing causes it to be reversed again (wrong). So don't.
+	 */
+	if (midsession || current_storagetype == 0) {
+		c = ctrl_radiobuttons(s, NULL, 'w', 2,
+				  HELPCTX(no_help),
+				  storagetype_handler,
+				  P(ssd), "Sessions from registry", I(0), "Sessions from file", I(1), NULL);
+	} else {
+		c = ctrl_radiobuttons(s, NULL, 'w', 2,
+				  HELPCTX(no_help),
+				  storagetype_handler,
+				  P(ssd), "Sessions from file", I(1), "Sessions from registry", I(0), NULL);
+	}
+	/** HACK: END **/
+
     s = ctrl_getset(b, "Session", "otheropts", NULL);
     c = ctrl_radiobuttons(s, "Close window on exit:", 'w', 4,
 			  HELPCTX(session_coe),
=== putty.h
==================================================================
--- putty.h	(revision 7489)
+++ putty.h	(local)
@@ -598,6 +598,11 @@
     FontSpec widefont;
     FontSpec wideboldfont;
     int shadowboldoffset;
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 */
+	int session_storagetype;
 };
 
 /*
@@ -781,11 +786,18 @@
 void save_open_settings(void *sesskey, Config *cfg);
 void load_settings(char *section, Config * cfg);
 void load_open_settings(void *sesskey, Config *cfg);
-void get_sesslist(struct sesslist *, int allocate);
+int get_sesslist(struct sesslist *, int allocate, int storagetype); // HACK: PuTTYTray / PuTTY File
 void do_defaults(char *, Config *);
 void registry_cleanup(void);
 
 /*
+ * HACK: PuttyTray / PuTTY File
+ * Quick hack to load defaults from file
+ */
+void do_defaults_file(char *, Config *);
+void load_settings_file(char *section, Config * cfg);
+
+/*
  * Functions used by settings.c to provide platform-specific
  * default settings.
  * 
@@ -1081,7 +1093,7 @@
  */
 struct controlbox;
 void setup_config_box(struct controlbox *b, int midsession,
-		      int protocol, int protcfginfo);
+		      int protocol, int protcfginfo, int session_storagetype); // HACK: PuttyTray / PuTTY File - Added 'int session_storagetype'
 
 /*
  * Exports from minibidi.c.
=== settings.c
==================================================================
--- settings.c	(revision 7489)
+++ settings.c	(local)
@@ -328,6 +328,13 @@
     write_setting_i(sesskey, "ApplicationCursorKeys", cfg->app_cursor);
     write_setting_i(sesskey, "ApplicationKeypad", cfg->app_keypad);
     write_setting_i(sesskey, "NetHackKeypad", cfg->nethack_keypad);
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Save storagetype
+	 */
+    write_setting_i(sesskey, "StorageType", cfg->session_storagetype);
+
     write_setting_i(sesskey, "AltF4", cfg->alt_f4);
     write_setting_i(sesskey, "AltSpace", cfg->alt_space);
     write_setting_i(sesskey, "AltOnly", cfg->alt_only);
@@ -454,6 +461,19 @@
     close_settings_r(sesskey);
 }
 
+/*
+ * HACK: PuttyTray / PuTTY File
+ * Quick hack to load defaults from file
+ */
+void load_settings_file(char *section, Config * cfg)
+{
+    void *sesskey;
+	set_storagetype(1);
+    sesskey = open_settings_r(section);
+    load_open_settings(sesskey, cfg);
+    close_settings_r(sesskey);
+}
+
 void load_open_settings(void *sesskey, Config *cfg)
 {
     int i;
@@ -616,6 +636,13 @@
     gppi(sesskey, "ApplicationCursorKeys", 0, &cfg->app_cursor);
     gppi(sesskey, "ApplicationKeypad", 0, &cfg->app_keypad);
     gppi(sesskey, "NetHackKeypad", 0, &cfg->nethack_keypad);
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Save storagetype
+	 */
+	gppi(sesskey, "StorageType", 0, &cfg->session_storagetype);
+
     gppi(sesskey, "AltF4", 1, &cfg->alt_f4);
     gppi(sesskey, "AltSpace", 0, &cfg->alt_space);
     gppi(sesskey, "AltOnly", 0, &cfg->alt_only);
@@ -782,6 +809,15 @@
     load_settings(session, cfg);
 }
 
+/*
+ * HACK: PuttyTray / PuTTY File
+ * Quick hack to load defaults from file
+ */
+void do_defaults_file(char *session, Config * cfg)
+{
+    load_settings_file(session, cfg);
+}
+
 static int sessioncmp(const void *av, const void *bv)
 {
     const char *a = *(const char *const *) av;
@@ -802,18 +838,29 @@
     return strcmp(a, b);	       /* otherwise, compare normally */
 }
 
-void get_sesslist(struct sesslist *list, int allocate)
+/*
+ * HACK: PuttyTray / PuTTY File
+ * Updated get_sesslist with storagetype
+ */
+int get_sesslist(struct sesslist *list, int allocate, int storagetype) // HACK: PuTTYTray / PuTTY File - changed return type
 {
     char otherbuf[2048];
     int buflen, bufsize, i;
     char *p, *ret;
     void *handle;
 
+	// HACK: PUTTY FILE
+	int autoswitch = 0;
+	if (storagetype > 1) {
+		storagetype = storagetype - 2;
+		autoswitch = 1;
+	}
+
     if (allocate) {
 
 	buflen = bufsize = 0;
 	list->buffer = NULL;
-	if ((handle = enum_settings_start()) != NULL) {
+	if ((handle = enum_settings_start(storagetype)) != NULL) { // HACK: PuTTYTray / PuTTY File - storagetype
 	    do {
 		ret = enum_settings_next(handle, otherbuf, sizeof(otherbuf));
 		if (ret) {
@@ -832,6 +879,44 @@
 	list->buffer[buflen] = '\0';
 
 	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Switch to file mode if registry is empty (and in registry mode)
+	 */
+	if (autoswitch == 1 && storagetype != 1 && buflen == 0) {
+		storagetype = 1;
+
+		// Ok, this is a copy of the code above. Crude but working
+		buflen = bufsize = 0;
+		list->buffer = NULL;
+		if ((handle = enum_settings_start(1)) != NULL) { // Force file storage type
+			do {
+			ret = enum_settings_next(handle, otherbuf, sizeof(otherbuf));
+			if (ret) {
+				int len = strlen(otherbuf) + 1;
+				if (bufsize < buflen + len) {
+				bufsize = buflen + len + 2048;
+				list->buffer = sresize(list->buffer, bufsize, char);
+				}
+				strcpy(list->buffer + buflen, otherbuf);
+				buflen += strlen(list->buffer + buflen) + 1;
+			}
+			} while (ret);
+			enum_settings_finish(handle);
+		}
+		list->buffer = sresize(list->buffer, buflen + 1, char);
+		list->buffer[buflen] = '\0';
+	}
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * If registry is empty AND file store is empty, show empty registry
+	 */
+	if (autoswitch == 1 && storagetype == 1 && buflen == 0) {
+		storagetype = 0;
+		set_storagetype(storagetype);
+	}
+
+	/*
 	 * Now set up the list of sessions. Note that "Default
 	 * Settings" must always be claimed to exist, even if it
 	 * doesn't really.
@@ -866,4 +951,10 @@
 	list->buffer = NULL;
 	list->sessions = NULL;
     }
+
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Return storagetype
+	 */
+	return storagetype;
 }
=== storage.h
==================================================================
--- storage.h	(revision 7489)
+++ storage.h	(local)
@@ -15,6 +15,12 @@
  */
 
 /*
+ * HACK: PuttyTray / PuTTY File
+ * Function to force the storage loader to a certain type
+ */
+void set_storagetype(int new_storagetype);
+
+/*
  * Write a saved session. The caller is expected to call
  * open_setting_w() to get a `void *' handle, then pass that to a
  * number of calls to write_setting_s() and write_setting_i(), and
@@ -67,7 +73,7 @@
 /*
  * Enumerate all saved sessions.
  */
-void *enum_settings_start(void);
+void *enum_settings_start(int new_storagetype); // HACK: PuttyTray / PuTTY File - enum_settings_start with storagetype
 char *enum_settings_next(void *handle, char *buffer, int buflen);
 void enum_settings_finish(void *handle);
 
=== windows/windlg.c
==================================================================
--- windows/windlg.c	(revision 7489)
+++ windows/windlg.c	(local)
@@ -639,7 +639,7 @@
     int ret;
 
     ctrlbox = ctrl_new_box();
-    setup_config_box(ctrlbox, FALSE, 0, 0);
+    setup_config_box(ctrlbox, FALSE, 0, 0, 0); // HACK: PuttyTray / PuTTY File, Added 0 for 'int session_storagetype'
     win_setup_config_box(ctrlbox, &dp.hwnd, has_help(), FALSE, 0);
     dp_init(&dp);
     winctrl_init(&ctrls_base);
@@ -671,7 +671,7 @@
     backup_cfg = cfg;		       /* structure copy */
 
     ctrlbox = ctrl_new_box();
-    setup_config_box(ctrlbox, TRUE, cfg.protocol, protcfginfo);
+    setup_config_box(ctrlbox, TRUE, cfg.protocol, protcfginfo, cfg.session_storagetype); // HACK: PuttyTray / PuTTY File, Added 'session_storagetype'
     win_setup_config_box(ctrlbox, &dp.hwnd, has_help(), TRUE,
                          cfg.protocol);
     dp_init(&dp);
=== windows/window.c
==================================================================
--- windows/window.c	(revision 7489)
+++ windows/window.c	(local)
@@ -758,7 +758,11 @@
 	AppendMenu(popup_menus[CTXMENU].menu, MF_ENABLED, IDM_PASTE, "&Paste");
 
 	savedsess_menu = CreateMenu();
-	get_sesslist(&sesslist, TRUE);
+	/*
+	 * HACK: PuttyTray / PuTTY File
+	 * Added storagetype to get_sesslist
+	 */
+	get_sesslist(&sesslist, TRUE, cfg.session_storagetype);
 	update_savedsess_menu();
 
 	for (j = 0; j < lenof(popup_menus); j++) {
@@ -2010,8 +2014,12 @@
 	if ((HMENU)wParam == savedsess_menu) {
 	    /* About to pop up Saved Sessions sub-menu.
 	     * Refresh the session list. */
-	    get_sesslist(&sesslist, FALSE); /* free */
-	    get_sesslist(&sesslist, TRUE);
+		/*
+		 * HACK: PuttyTray / PuTTY File
+		 * Added storagetype to get_sesslist
+		 */
+	    get_sesslist(&sesslist, FALSE, cfg.session_storagetype); /* free */
+	    get_sesslist(&sesslist, TRUE, cfg.session_storagetype);
 	    update_savedsess_menu();
 	    return 0;
 	}
=== windows/winstore.c
==================================================================
--- windows/winstore.c	(revision 7489)
+++ windows/winstore.c	(local)
@@ -1,6 +1,9 @@
 /*
  * winstore.c: Windows-specific implementation of the interface
  * defined in storage.h.
+ *
+ * HACK: PuttyTray / PuTTY File
+ * Added file support for PuTTY Tray
  */
 
 #include <stdio.h>
@@ -27,6 +30,618 @@
     (HWND, int, HANDLE, DWORD, LPTSTR);
 static p_SHGetFolderPath_t p_SHGetFolderPath = NULL;
 
+// PUTTY Tray / PuTTY File - global storage type
+static int storagetype = 0;	// 0 = registry, 1 = file
+
+// PUTTY Tray / PuTTY File - extra variables / structs for file
+static char seedpath[2 * MAX_PATH + 10] = "\0";
+static char sesspath[2 * MAX_PATH] = "\0";
+static char sshkpath[2 * MAX_PATH] = "\0";
+static char oldpath[2 * MAX_PATH] = "\0";
+static char sessionsuffix[16] = "\0";
+static char keysuffix[16] = "\0";
+
+/* JK: structures for handling settings in memory as linked list */
+struct setItem {
+	char* key;
+	char* value;
+	struct setItem* next;
+};
+struct setPack {
+	unsigned int fromFile;
+	void* handle;
+	char* fileBuf;
+};
+
+// Forward declarations for helper functions
+static void mungestr(const char *in, char *out);
+static void unmungestr(const char *in, char *out, int outlen);
+static void registry_recursive_remove(HKEY key);
+
+// Forward declarations for file functions
+void *file_open_settings_w(const char *sessionname, char **errmsg);
+void file_write_setting_s(void *handle, const char *key, const char *value);
+void file_write_setting_i(void *handle, const char *key, int value);
+void file_write_setting_filename(void *handle, const char *key, Filename value);
+void file_write_setting_fontspec(void *handle, const char *key, FontSpec font);
+void file_close_settings_w(void *handle);
+void *file_open_settings_r(const char *sessionname);
+char *file_read_setting_s(void *handle, const char *key, char *buffer, int buflen);
+int file_read_setting_i(void *handle, const char *key, int defvalue);
+int file_read_setting_filename(void *handle, const char *key, Filename *value);
+int file_read_setting_fontspec(void *handle, const char *key, FontSpec *font);
+void file_close_settings_r(void *handle);
+void file_del_settings(const char *sessionname);
+void *file_enum_settings_start();
+char *file_enum_settings_next(void *handle, char *buffer, int buflen);
+void file_enum_settings_finish(void *handle);
+int file_verify_host_key(const char *hostname, int port, const char *keytype, const char *key);
+void file_store_host_key(const char *hostname, int port, const char *keytype, const char *key);
+
+// Forward declarations for registry functions
+void *reg_open_settings_w(const char *sessionname, char **errmsg);
+void reg_write_setting_s(void *handle, const char *key, const char *value);
+void reg_write_setting_i(void *handle, const char *key, int value);
+void reg_write_setting_filename(void *handle, const char *key, Filename value);
+void reg_write_setting_fontspec(void *handle, const char *key, FontSpec font);
+void reg_close_settings_w(void *handle);
+void *reg_open_settings_r(const char *sessionname);
+char *reg_read_setting_s(void *handle, const char *key, char *buffer, int buflen);
+int reg_read_setting_i(void *handle, const char *key, int defvalue);
+int reg_read_setting_filename(void *handle, const char *key, Filename *value);
+int reg_read_setting_fontspec(void *handle, const char *key, FontSpec *font);
+void reg_close_settings_r(void *handle);
+void reg_del_settings(const char *sessionname);
+void *reg_enum_settings_start();
+char *reg_enum_settings_next(void *handle, char *buffer, int buflen);
+void reg_enum_settings_finish(void *handle);
+int reg_verify_host_key(const char *hostname, int port, const char *keytype, const char *key);
+void reg_store_host_key(const char *hostname, int port, const char *keytype, const char *key);
+
+
+/*
+ * Sets storage type
+ */
+void set_storagetype(int new_storagetype)
+{
+	storagetype = new_storagetype;
+}
+
+
+/*
+ * Write a saved session. The caller is expected to call
+ * open_setting_w() to get a `void *' handle, then pass that to a
+ * number of calls to write_setting_s() and write_setting_i(), and
+ * then close it using close_settings_w(). At the end of this call
+ * sequence the settings should have been written to the PuTTY
+ * persistent storage area.
+ *
+ * A given key will be written at most once while saving a session.
+ * Keys may be up to 255 characters long.  String values have no length
+ * limit.
+ * 
+ * Any returned error message must be freed after use.
+ *
+ * STORAGETYPE SWITCHER
+ */
+void *open_settings_w(const char *sessionname, char **errmsg)
+{
+	if (storagetype == 1) {
+		return file_open_settings_w(sessionname, errmsg);
+	} else {
+		return reg_open_settings_w(sessionname, errmsg);
+	}
+}
+
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void write_setting_s(void *handle, const char *key, const char *value)
+{
+	if (storagetype == 1) {
+		file_write_setting_s(handle, key, value);
+	} else {
+		reg_write_setting_s(handle, key, value);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void write_setting_i(void *handle, const char *key, int value)
+{
+	if (storagetype == 1) {
+		file_write_setting_i(handle, key, value);
+	} else {
+		reg_write_setting_i(handle, key, value);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void write_setting_filename(void *handle, const char *name, Filename result)
+{
+	if (storagetype == 1) {
+		file_write_setting_filename(handle, name, result);
+	} else {
+		reg_write_setting_filename(handle, name, result);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void write_setting_fontspec(void *handle, const char *name, FontSpec font)
+{
+	if (storagetype == 1) {
+		file_write_setting_fontspec(handle, name, font);
+	} else {
+		reg_write_setting_fontspec(handle, name, font);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void close_settings_w(void *handle)
+{
+	if (storagetype == 1) {
+		file_close_settings_w(handle);
+	} else {
+		reg_close_settings_w(handle);
+	}
+}
+
+/*
+ * Read a saved session. The caller is expected to call
+ * open_setting_r() to get a `void *' handle, then pass that to a
+ * number of calls to read_setting_s() and read_setting_i(), and
+ * then close it using close_settings_r().
+ * 
+ * read_setting_s() writes into the provided buffer and returns a
+ * pointer to the same buffer.
+ * 
+ * If a particular string setting is not present in the session,
+ * read_setting_s() can return NULL, in which case the caller
+ * should invent a sensible default. If an integer setting is not
+ * present, read_setting_i() returns its provided default.
+ * 
+ * read_setting_filename() and read_setting_fontspec() each read into
+ * the provided buffer, and return zero if they failed to.
+ *
+ * STORAGETYPE SWITCHER
+ */
+void *open_settings_r(const char *sessionname)
+{
+	if (storagetype == 1) {
+		return file_open_settings_r(sessionname);
+	} else {
+		return reg_open_settings_r(sessionname);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+char *read_setting_s(void *handle, const char *key, char *buffer, int buflen)
+{
+	if (storagetype == 1) {
+		return file_read_setting_s(handle, key, buffer, buflen);
+	} else {
+		return reg_read_setting_s(handle, key, buffer, buflen);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+int read_setting_i(void *handle, const char *key, int defvalue)
+{
+	if (storagetype == 1) {
+		return file_read_setting_i(handle, key, defvalue);
+	} else {
+		return reg_read_setting_i(handle, key, defvalue);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+int read_setting_fontspec(void *handle, const char *name, FontSpec *result)
+{
+	if (storagetype == 1) {
+		return file_read_setting_fontspec(handle, name, result);
+	} else {
+		return reg_read_setting_fontspec(handle, name, result);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+int read_setting_filename(void *handle, const char *name, Filename *result)
+{
+	if (storagetype == 1) {
+		return file_read_setting_filename(handle, name, result);
+	} else {
+		return reg_read_setting_filename(handle, name, result);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void close_settings_r(void *handle)
+{
+	if (storagetype == 1) {
+		file_close_settings_r(handle);
+	} else {
+		reg_close_settings_r(handle);
+	}
+}
+
+/*
+ * Delete a whole saved session.
+ *
+ * STORAGETYPE SWITCHER
+ */
+void del_settings(const char *sessionname)
+{
+	if (storagetype == 1) {
+		file_del_settings(sessionname);
+	} else {
+		reg_del_settings(sessionname);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void *enum_settings_start(int new_storagetype)
+{
+	storagetype = new_storagetype;
+
+	if (storagetype == 1) {
+		return file_enum_settings_start();
+	} else {
+		return reg_enum_settings_start();
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+char *enum_settings_next(void *handle, char *buffer, int buflen)
+{
+	if (storagetype == 1) {
+		return file_enum_settings_next(handle, buffer, buflen);
+	} else {
+		return reg_enum_settings_next(handle, buffer, buflen);
+	}
+}
+
+/*
+ * STORAGETYPE SWITCHER
+ */
+void enum_settings_finish(void *handle)
+{
+	if (storagetype == 1) {
+		file_enum_settings_finish(handle);
+	} else {
+		reg_enum_settings_finish(handle);
+	}
+}
+
+
+/* ----------------------------------------------------------------------
+ * Functions to access PuTTY's host key database.
+ */
+
+/*
+ * See if a host key matches the database entry. Return values can
+ * be 0 (entry matches database), 1 (entry is absent in database),
+ * or 2 (entry exists in database and is different).
+ *
+ * STORAGETYPE SWITCHER
+ */
+int verify_host_key(const char *hostname, int port, const char *keytype, const char *key)
+{
+	if (storagetype == 1) {
+		return file_verify_host_key(hostname, port, keytype, key);
+	} else {
+		return reg_verify_host_key(hostname, port, keytype, key);
+	}
+}
+
+/*
+ * Write a host key into the database, overwriting any previous
+ * entry that might have been there.
+ *
+ * STORAGETYPE SWITCHER
+ */
+void store_host_key(const char *hostname, int port, const char *keytype, const char *key)
+{
+	if (storagetype == 1) {
+		file_store_host_key(hostname, port, keytype, key);
+	} else {
+		reg_store_host_key(hostname, port, keytype, key);
+	}
+}
+
+
+/* ----------------------------------------------------------------------
+ * PUTTY FILE HELPERS (not part of storage.h)
+ */
+/* JK: my generic function for simplyfing error reporting */
+DWORD errorShow(const char* pcErrText, const char* pcErrParam) {
+
+	HWND hwRodic;
+	DWORD erChyba;
+	char pcBuf[16];
+	char* pcHlaska = snewn(strlen(pcErrParam) + strlen(pcErrText) + 31, char);
+	
+	erChyba = GetLastError();		
+	ltoa(erChyba, pcBuf, 10);
+
+	strcpy(pcHlaska, "Error: ");
+	strcat(pcHlaska, pcErrText);
+	strcat(pcHlaska, "\n");	
+
+	if (pcErrParam) {
+		strcat(pcHlaska, pcErrParam);
+		strcat(pcHlaska, "\n");
+	}
+    strcat(pcHlaska, "Error code: ");
+	strcat(pcHlaska, pcBuf);
+
+    /* JK: get parent-window and show */
+    hwRodic = GetActiveWindow();
+    if (hwRodic != NULL) { hwRodic = GetLastActivePopup(hwRodic);}
+  
+	if (MessageBox(hwRodic, pcHlaska, "Error", MB_OK|MB_APPLMODAL|MB_ICONEXCLAMATION) == 0) {
+        /* JK: this is really bad -> just ignore */
+        return 0;
+    }
+
+	sfree(pcHlaska);
+	return erChyba;
+};
+
+/* JK: pack string for use as filename - pack < > : " / \ | */
+static void packstr(const char *in, char *out) {
+    while (*in) {
+		if (*in == '<' || *in == '>' || *in == ':' || *in == '"' ||
+	    *in == '/' || *in == '|') {
+	    *out++ = '%';
+	    *out++ = hex[((unsigned char) *in) >> 4];
+	    *out++ = hex[((unsigned char) *in) & 15];
+	} else
+	    *out++ = *in;
+	in++;
+    }
+    *out = '\0';
+    return;
+}
+
+/*
+ * JK: create directory if specified as dir1\dir2\dir3 and dir1|2 doesn't exists
+ * handle if part of path already exists
+*/
+int createPath(char* dir) {
+    char *p;
+
+	p = strrchr(dir, '\\');
+
+	if (p == NULL) {
+		/* what if it already exists */
+		if (!SetCurrentDirectory(dir)) {
+			CreateDirectory(dir, NULL);
+			return SetCurrentDirectory(dir);
+		}
+		return 1;
+	}
+	
+	*p = '\0';
+	createPath(dir);
+	*p = '\\';
+	++p;
+
+	/* what if it already exists */
+	if (!SetCurrentDirectory(dir)) {
+		CreateDirectory(p, NULL);
+		return SetCurrentDirectory(p);
+	}
+	return 1;
+}
+
+/*
+ * JK: join path pcMain.pcSuf solving extra cases to pcDest
+ * expecting - pcMain as path from WinAPI ::GetCurrentDirectory()/GetModuleFileName()
+ *           - pcSuf as user input path from config (at least MAX_PATH long)
+*/
+char* joinPath(char* pcDest, char* pcMain, char* pcSuf) {
+
+	char* pcBuf = snewn(MAX_PATH+1, char);
+
+	/* at first ExpandEnvironmentStrings */
+	if (0 == ExpandEnvironmentStrings(pcSuf, pcBuf, MAX_PATH)) {
+		/* JK: failure -> revert back - but it ussualy won't work, so report error to user! */
+		errorShow("Unable to ExpandEnvironmentStrings for session path", pcSuf);
+		strncpy(pcBuf, pcSuf, strlen(pcSuf));
+	}
+	/* now ExpandEnvironmentStringsForUser - only on win2000Pro and above */
+	/* It's much more tricky than I've expected, so it's ToDo */
+	/*
+	static HMODULE userenv_module = NULL;
+	typedef BOOL (WINAPI *p_ExpandESforUser_t) (HANDLE, LPCTSTR, LPTSTR, DWORD);
+	static p_ExpandESforUser_t p_ExpandESforUser = NULL;
+	
+	HMODULE userenv_module = LoadLibrary("USERENV.DLL");
+
+	if (userenv_module) {
+	    p_ExpandESforUser = (p_ExpandESforUser_t) GetProcAddress(shell32_module, "ExpandEnvironmentStringsForUserA");
+		
+		if (p_ExpandESforUser) {
+
+			TOKEN_IMPERSONATE
+
+			if (0 == (p_ExpandESforUser(NULL, pcSuf, pcBuf,	MAX_PATH))) {
+	    		/* JK: failure -> revert back - but it ussualy won't work, so report error to user! *//*
+				errorShow("Unable to ExpandEnvironmentStringsForUser for session path", pcBuf);
+				strncpy(pcSuf, pcBuf, strlen(pcSuf));
+			}
+		}
+	}*/
+
+	/* expand done, resutl in pcBuf */
+
+	if ((*pcBuf == '/') || (*pcBuf == '\\')) {
+		/* everything ok */
+		strcpy(pcDest, pcMain);
+		strcat(pcDest, pcBuf);
+	}
+	else {
+		if (*(pcBuf+1) == ':') {
+			/* absolute path */
+			strcpy(pcDest, pcBuf);
+		}
+		else {
+			/* some weird relative path - add '\' */
+			strcpy(pcDest, pcMain);
+			strcat(pcDest, "\\");
+			strcat(pcDest, pcBuf);
+		}
+	}
+	sfree(pcBuf);
+	return pcDest;
+}
+
+/*
+ * JK: init path variables from config or otherwise
+ * as of 1.5 GetModuleFileName solves our currentDirectory problem
+*/
+int loadPath() {
+
+	char *fileCont = NULL;
+	DWORD fileSize;
+	DWORD bytesRead;
+	char *p = NULL;
+	char *p2 = NULL;
+	HANDLE hFile;
+
+	char* puttypath = snewn( (MAX_PATH*2), char);
+
+	/* JK:  save path/curdir */
+	GetCurrentDirectory( (MAX_PATH*2), oldpath);
+
+	/* JK: get where putty.exe is */
+	if (GetModuleFileName(NULL, puttypath, (MAX_PATH*2)) != 0)
+	{
+		p = strrchr(puttypath, '\\');
+		if (p)
+		{
+			*p = '\0';
+		}
+		SetCurrentDirectory(puttypath);
+	}
+	else GetCurrentDirectory( (MAX_PATH*2), puttypath);
+
+	/* JK: set default values - if there is a config file, it will be overwitten */
+	strcpy(sesspath, puttypath);
+	strcat(sesspath, "\\sessions");
+	strcpy(sshkpath, puttypath);
+	strcat(sshkpath, "\\sshhostkeys");
+	strcpy(seedpath, puttypath);
+	strcat(seedpath, "\\putty.rnd");
+
+	hFile = CreateFile("putty.conf",GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+
+	/* JK: now we can pre-clean-up */
+	SetCurrentDirectory(oldpath);
+
+	if (hFile != INVALID_HANDLE_VALUE) {
+		fileSize = GetFileSize(hFile, NULL);
+		fileCont = snewn(fileSize+16, char);
+
+		if (!ReadFile(hFile, fileCont, fileSize, &bytesRead, NULL)) {
+			errorShow("Unable to read configuration file, falling back to defaults", NULL);
+		
+			/* JK: default values are already there and clean-up at end */
+		}
+		else {
+			/* JK: parse conf file to path variables */
+			*(fileCont+fileSize) = '\0';
+			p = fileCont;
+			while (p) {
+				if (*p == ';') {	/* JK: comment -> skip line */
+					p = strchr(p, '\n');
+					++p;
+					continue;
+				}
+				p2 = strchr(p, '=');
+				if (!p2) break;
+				*p2 = '\0';
+				++p2;
+
+				if (!strcmp(p, "sessions")) {
+					p = strchr(p2, '\n');
+					*p = '\0';
+					joinPath(sesspath, puttypath, p2);
+					p2 = sesspath+strlen(sesspath)-1;
+					while ((*p2 == ' ')||(*p2 == '\n')||(*p2 == '\r')||(*p2 == '\t')) --p2;
+					*(p2+1) = '\0';
+				}
+				else if (!strcmp(p, "sshhostkeys")) {
+					p = strchr(p2, '\n');
+					*p = '\0';
+					joinPath(sshkpath, puttypath, p2);
+					p2 = sshkpath+strlen(sshkpath)-1;
+					while ((*p2 == ' ')||(*p2 == '\n')||(*p2 == '\r')||(*p2 == '\t')) --p2;
+					*(p2+1) = '\0';
+				}
+				else if (!strcmp(p, "seedfile")) {
+					p = strchr(p2, '\n');
+					*p = '\0';
+					joinPath(seedpath, puttypath, p2);			
+					p2 = seedpath+strlen(seedpath)-1;
+					while ((*p2 == ' ')||(*p2 == '\n')||(*p2 == '\r')||(*p2 == '\t')) --p2;
+					*(p2+1) = '\0';
+				}
+				else if (!strcmp(p, "sessionsuffix")) {
+					p = strchr(p2, '\n');
+					*p = '\0';
+					strcpy(sessionsuffix, p2);
+					p2 = sessionsuffix+strlen(sessionsuffix)-1;
+					while ((*p2 == ' ')||(*p2 == '\n')||(*p2 == '\r')||(*p2 == '\t')) --p2;
+					*(p2+1) = '\0';
+				}
+				else if (!strcmp(p, "keysuffix")) {
+					p = strchr(p2, '\n');
+					*p = '\0';
+					strcpy(keysuffix, p2);
+					p2 = keysuffix+strlen(keysuffix)-1;
+					while ((*p2 == ' ')||(*p2 == '\n')||(*p2 == '\r')||(*p2 == '\t')) --p2;
+					*(p2+1) = '\0';
+				}
+				++p;
+			}
+		}
+		CloseHandle(hFile);
+		sfree(fileCont);
+	}
+	/* else - INVALID_HANDLE {
+		 * JK: unable to read conf file - probably doesn't exists
+		 * we won't create one, user wants putty light, just fall back to defaults
+		 * and defaults are already there
+	}*/
+
+	sfree(puttypath);
+	return 1;
+}
+
+
 static void mungestr(const char *in, char *out)
 {
     int candot = 0;
@@ -72,7 +687,14 @@
     return;
 }
 
-void *open_settings_w(const char *sessionname, char **errmsg)
+
+/* ---------------------------------------------------------------------------------------------------------
+ * ---------------------------------------------------------------------------------------------------------
+ * REGISTRY FUNCTIONS
+ * ---------------------------------------------------------------------------------------------------------
+ * -------------------------------------------------------------------------------------------------------*/
+
+void *reg_open_settings_w(const char *sessionname, char **errmsg)
 {
     HKEY subkey1, sesskey;
     int ret;
@@ -105,26 +727,26 @@
     return (void *) sesskey;
 }
 
-void write_setting_s(void *handle, const char *key, const char *value)
+void reg_write_setting_s(void *handle, const char *key, const char *value)
 {
     if (handle)
 	RegSetValueEx((HKEY) handle, key, 0, REG_SZ, value,
 		      1 + strlen(value));
 }
 
-void write_setting_i(void *handle, const char *key, int value)
+void reg_write_setting_i(void *handle, const char *key, int value)
 {
     if (handle)
 	RegSetValueEx((HKEY) handle, key, 0, REG_DWORD,
 		      (CONST BYTE *) &value, sizeof(value));
 }
 
-void close_settings_w(void *handle)
+void reg_close_settings_w(void *handle)
 {
     RegCloseKey((HKEY) handle);
 }
 
-void *open_settings_r(const char *sessionname)
+void *reg_open_settings_r(const char *sessionname)
 {
     HKEY subkey1, sesskey;
     char *p;
@@ -149,7 +771,7 @@
     return (void *) sesskey;
 }
 
-char *read_setting_s(void *handle, const char *key, char *buffer, int buflen)
+char *reg_read_setting_s(void *handle, const char *key, char *buffer, int buflen)
 {
     DWORD type, size;
     size = buflen;
@@ -162,7 +784,7 @@
 	return buffer;
 }
 
-int read_setting_i(void *handle, const char *key, int defvalue)
+int reg_read_setting_i(void *handle, const char *key, int defvalue)
 {
     DWORD type, val, size;
     size = sizeof(val);
@@ -176,61 +798,61 @@
 	return val;
 }
 
-int read_setting_fontspec(void *handle, const char *name, FontSpec *result)
+int reg_read_setting_fontspec(void *handle, const char *name, FontSpec *result)
 {
     char *settingname;
     FontSpec ret;
 
-    if (!read_setting_s(handle, name, ret.name, sizeof(ret.name)))
+    if (!reg_read_setting_s(handle, name, ret.name, sizeof(ret.name)))
 	return 0;
     settingname = dupcat(name, "IsBold", NULL);
-    ret.isbold = read_setting_i(handle, settingname, -1);
+    ret.isbold = reg_read_setting_i(handle, settingname, -1);
     sfree(settingname);
     if (ret.isbold == -1) return 0;
     settingname = dupcat(name, "CharSet", NULL);
-    ret.charset = read_setting_i(handle, settingname, -1);
+    ret.charset = reg_read_setting_i(handle, settingname, -1);
     sfree(settingname);
     if (ret.charset == -1) return 0;
     settingname = dupcat(name, "Height", NULL);
-    ret.height = read_setting_i(handle, settingname, INT_MIN);
+    ret.height = reg_read_setting_i(handle, settingname, INT_MIN);
     sfree(settingname);
     if (ret.height == INT_MIN) return 0;
     *result = ret;
     return 1;
 }
 
-void write_setting_fontspec(void *handle, const char *name, FontSpec font)
+void reg_write_setting_fontspec(void *handle, const char *name, FontSpec font)
 {
     char *settingname;
 
-    write_setting_s(handle, name, font.name);
+    reg_write_setting_s(handle, name, font.name);
     settingname = dupcat(name, "IsBold", NULL);
-    write_setting_i(handle, settingname, font.isbold);
+    reg_write_setting_i(handle, settingname, font.isbold);
     sfree(settingname);
     settingname = dupcat(name, "CharSet", NULL);
-    write_setting_i(handle, settingname, font.charset);
+    reg_write_setting_i(handle, settingname, font.charset);
     sfree(settingname);
     settingname = dupcat(name, "Height", NULL);
-    write_setting_i(handle, settingname, font.height);
+    reg_write_setting_i(handle, settingname, font.height);
     sfree(settingname);
 }
 
-int read_setting_filename(void *handle, const char *name, Filename *result)
+int reg_read_setting_filename(void *handle, const char *name, Filename *result)
 {
-    return !!read_setting_s(handle, name, result->path, sizeof(result->path));
+    return !!reg_read_setting_s(handle, name, result->path, sizeof(result->path));
 }
 
-void write_setting_filename(void *handle, const char *name, Filename result)
+void reg_write_setting_filename(void *handle, const char *name, Filename result)
 {
-    write_setting_s(handle, name, result.path);
+    reg_write_setting_s(handle, name, result.path);
 }
 
-void close_settings_r(void *handle)
+void reg_close_settings_r(void *handle)
 {
     RegCloseKey((HKEY) handle);
 }
 
-void del_settings(const char *sessionname)
+void reg_del_settings(const char *sessionname)
 {
     HKEY subkey1;
     char *p;
@@ -246,12 +868,15 @@
     RegCloseKey(subkey1);
 }
 
+// Saved sessions enumeration.
 struct enumsettings {
     HKEY key;
     int i;
+	int fromFile;
+	HANDLE hFile;
 };
 
-void *enum_settings_start(void)
+void *reg_enum_settings_start(void)
 {
     struct enumsettings *ret;
     HKEY key;
@@ -268,7 +893,7 @@
     return ret;
 }
 
-char *enum_settings_next(void *handle, char *buffer, int buflen)
+char *reg_enum_settings_next(void *handle, char *buffer, int buflen)
 {
     struct enumsettings *e = (struct enumsettings *) handle;
     char *otherbuf;
@@ -283,7 +908,7 @@
     }
 }
 
-void enum_settings_finish(void *handle)
+void reg_enum_settings_finish(void *handle)
 {
     struct enumsettings *e = (struct enumsettings *) handle;
     RegCloseKey(e->key);
@@ -301,7 +926,7 @@
     mungestr(hostname, buffer + strlen(buffer));
 }
 
-int verify_host_key(const char *hostname, int port,
+int reg_verify_host_key(const char *hostname, int port,
 		    const char *keytype, const char *key)
 {
     char *otherstr, *regname;
@@ -407,7 +1032,7 @@
 	return 0;		       /* key matched OK in registry */
 }
 
-void store_host_key(const char *hostname, int port,
+void reg_store_host_key(const char *hostname, int port,
 		    const char *keytype, const char *key)
 {
     char *regname;
@@ -457,6 +1082,15 @@
     HANDLE rethandle;
     char seedpath[2 * MAX_PATH + 10] = "\0";
 
+	/* PuttyTray / PuTTY File - HACK STARTS HERE */
+	if (seedpath != '\0') {
+		/* JK: In PuTTY 0.58 this won't ever happen - this function was called only if (!seedpath[0])
+		 * This changed in PuTTY 0.59 - read the long comment below
+		 */
+		return INVALID_HANDLE_VALUE;
+	}
+	/* PuttyTray / PuTTY File - HACK ENDS HERE */
+
     /*
      * Iterate over a selection of possible random seed paths until
      * we find one that works.
@@ -654,3 +1288,852 @@
      * Now we're done.
      */
 }
+
+
+/* ---------------------------------------------------------------------------------------------------------
+ * ---------------------------------------------------------------------------------------------------------
+ * FILE FUNCTIONS
+ * ---------------------------------------------------------------------------------------------------------
+ * -------------------------------------------------------------------------------------------------------*/
+
+void *file_open_settings_w(const char *sessionname, char **errmsg)
+{
+    char *p;
+	struct setPack* sp;
+    *errmsg = NULL;
+
+	if (!sessionname || !*sessionname) {
+		sessionname = "Default Settings";
+	}
+
+	/* JK: if sessionname contains [registry] -> cut it off */
+	/*if ( *(sessionname+strlen(sessionname)-1) == ']') {
+		p = strrchr(sessionname, '[');
+		*(p-1) = '\0';
+	}*/
+
+    p = snewn(3 * strlen(sessionname) + 1, char);
+    mungestr(sessionname, p);
+
+	sp = snew( struct setPack );
+	sp->fromFile = 0;
+	sp->handle = NULL;
+
+	/* JK: secure pack for filename */
+	sp->fileBuf = snewn(3 * strlen(p) + 1 + 16, char);
+    packstr(p, sp->fileBuf);
+	strcat(sp->fileBuf, sessionsuffix);
+	sfree(p);
+
+	return sp;
+}
+
+void file_write_setting_s(void *handle, const char *key, const char *value)
+{
+	struct setItem *st;
+
+	if (handle) {
+		/* JK: counting max lenght of keys/values */
+		((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(key)+1);
+		((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(value)+1);
+
+		st = ((struct setPack*) handle)->handle;
+		while (st) {
+			if ( strcmp(st->key, key) == 0) {
+				/* this key already set -> reset */
+				sfree(st->value);
+				st->value = snewn( strlen(value)+1, char);
+				strcpy(st->value, value);
+				return;
+			}
+			st = st->next;
+		}
+		/* JK: key not found -> add to begin */
+		st = snew( struct setItem );
+		st->key = snewn( strlen(key)+1, char);
+		strcpy(st->key, key);
+		st->value = snewn( strlen(value)+1, char);
+		strcpy(st->value, value);
+		st->next = ((struct setPack*) handle)->handle;
+		((struct setPack*) handle)->handle = st;
+	}
+}
+
+void file_write_setting_i(void *handle, const char *key, int value)
+{
+	struct setItem *st;
+
+	if (handle) {
+		/* JK: counting max lenght of keys/values */
+		((struct setPack*) handle)->fromFile = max(((struct setPack*) handle)->fromFile, strlen(key)+1);
+
+		st = ((struct setPack*) handle)->handle;
+		while (st) {
+			if ( strcmp(st->key, key) == 0) {
+				/* this key already set -> reset */
+				sfree(st->value);
+				st->value = snewn(16, char);
+				itoa(value, st->value, 10);
+				return;
+			}
+			st = st->next;
+		}
+		/* JK: key not found -> add to begin */
+		st = snew( struct setItem );
+		st->key = snewn( strlen(key)+1, char);
+		strcpy(st->key, key);
+		st->value = snewn(16, char);
+		itoa(value, st->value, 10);
+		st->next = ((struct setPack*) handle)->handle;
+		((struct setPack*) handle)->handle = st;
+	}
+}
+
+void file_close_settings_w(void *handle)
+{
+	HANDLE hFile;
+	DWORD written;
+	WIN32_FIND_DATA FindFile;
+	char *p;
+	struct setItem *st1,*st2;
+	int writeok;
+
+	if (!handle) return;
+
+	/* JK: we will write to disk now - open file, filename stored in handle already packed */
+	if ((hFile = FindFirstFile(sesspath, &FindFile)) == INVALID_HANDLE_VALUE) {
+		if (!createPath(sesspath)) {
+			errorShow("Unable to create directory for storing sessions", sesspath);
+			return;
+		}
+	}
+	FindClose(hFile);
+	GetCurrentDirectory( (MAX_PATH*2), oldpath);
+	SetCurrentDirectory(sesspath);
+
+	hFile = CreateFile( ((struct setPack*) handle)->fileBuf, GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
+	if (hFile == INVALID_HANDLE_VALUE) {
+		errorShow("Unable to open file for writing", ((struct setPack*) handle)->fileBuf );
+		return;
+	}
+
+	/* JK: allocate enough memory for all keys/values */
+	p = snewn( max( 3* ((struct setPack*) handle)->fromFile ,16), char);
+
+	/* JK: process linked list */
+	st1 = ((struct setPack*) handle)->handle;
+	writeok = 1;
+
+	while (st1) {
+		mungestr(st1->key, p);
+		writeok = writeok && WriteFile( (HANDLE) hFile, p, strlen(p), &written, NULL);
+		writeok = writeok && WriteFile( (HANDLE) hFile, "\\", 1, &written, NULL);
+
+		mungestr(st1->value, p);
+		writeok = writeok && WriteFile( (HANDLE) hFile, p, strlen(p), &written, NULL);
+		writeok = writeok && WriteFile( (HANDLE) hFile, "\\\n", 2, &written, NULL);
+
+		if (!writeok) {
+			errorShow("Unable to save settings", st1->key);
+			return;
+			/* JK: memory should be freed here - fixme */
+		}
+
+		st2 = st1->next;
+		sfree(st1->key);
+		sfree(st1->value);
+		sfree(st1);
+		st1 = st2;
+	}
+
+	sfree(((struct setPack*) handle)->fileBuf);
+	CloseHandle( (HANDLE)hFile );
+	SetCurrentDirectory(oldpath);
+}
+
+void *file_open_settings_r(const char *sessionname)
+{
+    HKEY subkey1, sesskey;
+    char *p;
+	char *fileCont;
+	DWORD fileSize;
+	DWORD bytesRead;
+	HANDLE hFile;
+	struct setPack* sp;
+	struct setItem *st1, *st2;
+
+	sp = snew( struct setPack );
+
+	if (!sessionname || !*sessionname) {
+		sessionname = "Default Settings";
+	}
+
+	/* JK: in the first call of this function we initialize path variables */
+	if (*sesspath == '\0') {
+		loadPath();
+	}
+
+	/* JK: if sessionname contains [registry] -> cut it off in another buffer */
+	/*if ( *(sessionname+strlen(sessionname)-1) == ']') {
+		char* ses = snewn(strlen(sessionname)+1, char);
+		strcpy(ses, sessionname);
+
+		p = strrchr(ses, '[');
+		*(p-1) = '\0';
+
+		p = snewn(3 * strlen(ses) + 1, char);
+		mungestr(ses, p);
+		sfree(ses);
+
+		sp->fromFile = 0;
+	}
+	else {*/
+		p = snewn(3 * strlen(sessionname) + 1 + 16, char);
+		mungestr(sessionname, p);
+		strcat(p, sessionsuffix);
+
+		sp->fromFile = 1;
+	//}
+
+	/* JK: default settings must be read from registry */
+	/* 8.1.2007 - 0.1.6 try to load them from file if exists - nasty code duplication */
+	if (!strcmp(sessionname, "Default Settings")) {
+		GetCurrentDirectory( (MAX_PATH*2), oldpath);
+		if (SetCurrentDirectory(sesspath)) {
+			hFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+		}
+		else {
+			hFile = INVALID_HANDLE_VALUE;
+		}
+		SetCurrentDirectory(oldpath);
+		
+		if (hFile == INVALID_HANDLE_VALUE) {
+			sp->fromFile = 0;
+		}
+		else {
+			sp->fromFile = 1;
+			CloseHandle(hFile);
+		}
+	}
+
+	if (sp->fromFile) {
+		/* JK: session is in file -> open dir/file */
+		GetCurrentDirectory( (MAX_PATH*2), oldpath);
+		if (SetCurrentDirectory(sesspath)) {
+			hFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+		}
+		else {
+			hFile = INVALID_HANDLE_VALUE;
+		}
+		SetCurrentDirectory(oldpath);
+		
+		if (hFile == INVALID_HANDLE_VALUE) {
+			/* JK: some error occured -> just report and fail */
+
+			/* JK: PSCP/PLINK always try to load settings for sessionname=hostname (to what PSCP/PLINK is just connecting)
+			   These settings usually doesn't exist.
+			   So for PSCP/PLINK, do not report error - so when compiling PSCP/PLINK, comment line below
+			   (errorShow("Unable to load file for reading", p);)
+			*/
+//#error read comment above
+			errorShow("Unable to load file for reading", p);
+
+			sfree(p);
+			return NULL;
+		}
+
+		/* JK: succes -> load structure setPack from file */
+		fileSize = GetFileSize(hFile, NULL);
+		fileCont = snewn(fileSize+16, char);
+
+		if (!ReadFile(hFile, fileCont, fileSize, &bytesRead, NULL)) {
+			errorShow("Unable to read session from file", p);
+			sfree(p);
+			return NULL;
+		}
+		sfree(p);
+
+		st1 = snew( struct setItem );
+		sp->fromFile = 1;
+		sp->handle = st1;
+		
+		p = fileCont;
+		sp->fileBuf = fileCont; /* JK: remeber for memory freeing */
+
+		/* pJK: arse file in format:
+		 * key1\value1\
+		 * ...
+		*/
+		while (p < (fileCont+fileSize)) {
+			st1->key = p;
+			p = strchr(p, '\\');
+			if (!p) break;
+			*p = '\0';
+			++p;
+			st1->value = p;
+			p = strchr(p, '\\');
+			if (!p) break;
+			*p = '\0';
+			++p;
+			++p; /* for "\\\n" - human readable files */
+
+			st2 = snew( struct setItem );
+			st2->next = NULL;
+			st2->key = NULL;
+			st2->value = NULL;
+
+			st1->next = st2;
+			st1 = st2;
+		}
+		CloseHandle(hFile);
+	}
+	else {
+		/* JK: session is in registry */
+		if (RegOpenKey(HKEY_CURRENT_USER, puttystr, &subkey1) != ERROR_SUCCESS) {
+			sesskey = NULL;
+		}
+		else {
+			if (RegOpenKey(subkey1, p, &sesskey) != ERROR_SUCCESS) {
+				sesskey = NULL;
+			}
+			RegCloseKey(subkey1);
+		}
+		sp->fromFile = 0;
+		sp->handle = sesskey;
+		sfree(p);
+	}
+
+	return sp;
+}
+
+char *file_read_setting_s(void *handle, const char *key, char *buffer, int buflen)
+{
+    DWORD type;
+	struct setItem *st;
+	char *p;
+	DWORD size = buflen;
+
+	if (!handle) return NULL;	/* JK: new in 0.1.3 */
+
+	if (((struct setPack*) handle)->fromFile) {
+		
+		p = snewn(3 * strlen(key) + 1, char);
+		mungestr(key, p);
+
+		st = ((struct setPack*) handle)->handle;
+		while (st->key) {
+			if ( strcmp(st->key, p) == 0) {
+				unmungestr(st->value, buffer, buflen);
+				return st->value;				
+			}
+			st = st->next;
+		}
+	}
+	else {
+		handle = ((struct setPack*) handle)->handle;
+
+		if (!handle || RegQueryValueEx((HKEY) handle, key, 0, &type, buffer, &size) != ERROR_SUCCESS ||	type != REG_SZ) {
+			return NULL;
+		}
+		else {
+			return buffer;
+		}
+	}
+	/* JK: should not end here -> value not found in file */
+	return NULL;
+}
+
+int file_read_setting_i(void *handle, const char *key, int defvalue)
+{
+    DWORD type, val, size;
+	struct setItem *st;
+    size = sizeof(val);
+
+	if (!handle) return 0;	/* JK: new in 0.1.3 */
+
+	if (((struct setPack*) handle)->fromFile) {
+		st = ((struct setPack*) handle)->handle;
+		while (st->key) {
+			if ( strcmp(st->key, key) == 0) {
+				return atoi(st->value);				
+			}
+			st = st->next;
+		}
+	}
+	else {
+		handle = ((struct setPack*) handle)->handle;
+
+		if (!handle || RegQueryValueEx((HKEY) handle, key, 0, &type, (BYTE *) &val, &size) != ERROR_SUCCESS || size != sizeof(val) || type != REG_DWORD) {
+			return defvalue;
+		}
+		else {
+			return val;
+		}
+	}
+	/* JK: should not end here -> value not found in file */
+	return defvalue;
+}
+
+int file_read_setting_fontspec(void *handle, const char *name, FontSpec *result)
+{
+    char *settingname;
+    FontSpec ret;
+
+    if (!file_read_setting_s(handle, name, ret.name, sizeof(ret.name)))
+	return 0;
+    settingname = dupcat(name, "IsBold", NULL);
+    ret.isbold = file_read_setting_i(handle, settingname, -1);
+    sfree(settingname);
+    if (ret.isbold == -1) return 0;
+    settingname = dupcat(name, "CharSet", NULL);
+    ret.charset = file_read_setting_i(handle, settingname, -1);
+    sfree(settingname);
+    if (ret.charset == -1) return 0;
+    settingname = dupcat(name, "Height", NULL);
+    ret.height = file_read_setting_i(handle, settingname, INT_MIN);
+    sfree(settingname);
+    if (ret.height == INT_MIN) return 0;
+    *result = ret;
+    return 1;
+}
+
+void file_write_setting_fontspec(void *handle, const char *name, FontSpec font)
+{
+    char *settingname;
+
+    file_write_setting_s(handle, name, font.name);
+    settingname = dupcat(name, "IsBold", NULL);
+    file_write_setting_i(handle, settingname, font.isbold);
+    sfree(settingname);
+    settingname = dupcat(name, "CharSet", NULL);
+    file_write_setting_i(handle, settingname, font.charset);
+    sfree(settingname);
+    settingname = dupcat(name, "Height", NULL);
+    file_write_setting_i(handle, settingname, font.height);
+    sfree(settingname);
+}
+
+int file_read_setting_filename(void *handle, const char *name, Filename *result)
+{
+    return !!file_read_setting_s(handle, name, result->path, sizeof(result->path));
+}
+
+void file_write_setting_filename(void *handle, const char *name, Filename result)
+{
+    file_write_setting_s(handle, name, result.path);
+}
+
+void file_close_settings_r(void *handle)
+{
+	if (!handle) return;	/* JK: new in 0.1.3 */
+
+	if (((struct setPack*) handle)->fromFile) {
+		struct setItem *st1, *st2;
+
+		st1 = ((struct setPack*) handle)->handle;
+		while (st1) {
+			st2 = st1->next;
+			sfree(st1);
+			st1 = st2;
+		}
+		sfree( ((struct setPack*) handle)->fileBuf );
+		sfree(handle);
+	}
+	else {
+		handle = ((struct setPack*) handle)->handle;
+	    RegCloseKey((HKEY) handle);
+	}
+}
+
+void file_del_settings(const char *sessionname)
+{
+    char *p;
+	char *p2;
+
+	/* JK: if sessionname contains [registry] -> cut it off and delete from registry */
+	/*if ( *(sessionname+strlen(sessionname)-1) == ']') {
+	    HKEY subkey1;
+
+		p = strrchr(sessionname, '[');
+		*(p-1) = '\0';
+
+		p = snewn(3 * strlen(sessionname) + 1, char);
+		mungestr(sessionname, p);
+		
+		if (RegOpenKey(HKEY_CURRENT_USER, puttystr, &subkey1) != ERROR_SUCCESS)	return;
+
+		RegDeleteKey(subkey1, p);
+		RegCloseKey(subkey1);
+	}
+	else {*/
+		/* JK: delete from file - file itself */
+
+		p = snewn(3 * strlen(sessionname) + 1, char);
+		mungestr(sessionname, p);
+		p2 = snewn(3 * strlen(p) + 1, char);
+		packstr(p, p2);
+
+		GetCurrentDirectory( (MAX_PATH*2), oldpath);
+		if (SetCurrentDirectory(sesspath)) {
+			if (!DeleteFile(p2))
+			{
+				errorShow("Unable to delete settings.", NULL);
+			}
+			SetCurrentDirectory(oldpath);
+		}
+	//}
+
+	sfree(p);
+}
+
+void *file_enum_settings_start(void)
+{
+    struct enumsettings *ret;
+    HKEY key;
+
+	/* JK: in the first call of this function we can initialize path variables */
+	if (*sesspath == '\0') {
+		loadPath();
+	}
+	/* JK: we have path variables */
+	
+	/* JK: let's do what this function should normally do */
+	ret = snew(struct enumsettings);
+
+	if (RegOpenKey(HKEY_CURRENT_USER, puttystr, &key) != ERROR_SUCCESS) {
+		/*
+		 * JK: nothing in registry -> pretend we found it, first call to file_enum_settings_next
+		 * will solve this by starting scanning dir sesspath
+		*/
+	}
+	ret->key = key;
+	ret->fromFile = 0;
+	ret->hFile = NULL;
+	ret->i = 0;
+
+    return ret;
+}
+
+char *file_enum_settings_next(void *handle, char *buffer, int buflen)
+{
+	struct enumsettings *e = (struct enumsettings *) handle;
+    WIN32_FIND_DATA FindFileData;
+	HANDLE hFile;
+	char *otherbuf;
+	
+	if (!handle) return NULL;	/* JK: new in 0.1.3 */
+	
+	otherbuf = snewn( (3*buflen)+1, char); /* must be here */
+
+	if (! ((struct enumsettings *)handle)->fromFile ) {
+
+	    /*if (RegEnumKey(e->key, e->i++, otherbuf, 3 * buflen) == ERROR_SUCCESS) {
+			unmungestr(otherbuf, buffer, buflen);
+			strcat(buffer, " [registry]");
+			sfree(otherbuf);
+			return buffer;
+		}
+		else {*/
+			/* JK: registry scanning done, starting scanning directory "sessions" */
+			((struct enumsettings *)handle)->fromFile = 1;
+			GetCurrentDirectory( (MAX_PATH*2), oldpath);
+			if (!SetCurrentDirectory(sesspath)) {
+				sfree(otherbuf);
+				return NULL;
+			}
+			hFile = FindFirstFile("*", &FindFileData);
+
+			/* JK: skip directories (extra check for "." and ".." too, seems to bug on some machines) */
+			while ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.') { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check
+				if (!FindNextFile(hFile,&FindFileData)) {
+					sfree(otherbuf);
+					return NULL;
+				}
+			}
+			/* JK: a file found */
+			if (hFile != INVALID_HANDLE_VALUE && !((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.')) { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check
+				((struct enumsettings *)handle)->hFile = hFile;
+				unmungestr(FindFileData.cFileName, buffer, buflen);
+				sfree(otherbuf);
+				/* JK: cut off sessionsuffix */
+				otherbuf = buffer + strlen(buffer) - strlen(sessionsuffix);
+				if (strncmp(otherbuf, sessionsuffix, strlen(sessionsuffix)) == 0) {
+					*otherbuf = '\0';
+				}
+				return buffer;
+			}
+			else {
+				/* JK: not a single file found -> give up */
+				sfree(otherbuf);
+				return NULL;
+			}
+		//}
+	}
+	else if ( ((struct enumsettings *)handle)->fromFile ) {
+		if (FindNextFile(((struct enumsettings *)handle)->hFile,&FindFileData) && !((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) || FindFileData.cFileName[0] == '.')) { // HACK: PUTTY TRAY / PUTTY FILE: Fixed directory check
+			unmungestr(FindFileData.cFileName, buffer, buflen);
+			sfree(otherbuf);
+			/* JK: cut off sessionsuffix */
+			otherbuf = buffer + strlen(buffer) - strlen(sessionsuffix);
+			if (strncmp(otherbuf, sessionsuffix, strlen(sessionsuffix)) == 0) {
+				*otherbuf = '\0';
+			}
+			return buffer;
+		}
+		else {
+			sfree(otherbuf);
+			return NULL;
+		}
+	}
+	/* JK: should not end here */
+	sfree(otherbuf);
+	return NULL;
+}
+
+void file_enum_settings_finish(void *handle)
+{
+    struct enumsettings *e = (struct enumsettings *) handle;
+	if (!handle) return;	/* JK: new in 0.1.3 */
+
+    RegCloseKey(e->key);
+	if (((struct enumsettings *)handle)->hFile != NULL) { FindClose(((struct enumsettings *)handle)->hFile); }
+	SetCurrentDirectory(oldpath);
+	sfree(e);
+}
+
+int file_verify_host_key(const char *hostname, int port,
+		    const char *keytype, const char *key)
+{
+    char *otherstr, *regname;
+    int len;
+	HKEY rkey;
+    DWORD readlen;
+    DWORD type;
+    int ret, compare, userMB;
+
+	DWORD fileSize;
+	DWORD bytesRW;
+	char *p;
+	HANDLE hFile;
+	WIN32_FIND_DATA FindFile;
+
+    len = 1 + strlen(key);
+
+    /* Now read a saved key in from the registry and see what it says. */
+    otherstr = snewn(len, char);
+    regname = snewn(3 * (strlen(hostname) + strlen(keytype)) + 15, char);
+
+    hostkey_regname(regname, hostname, port, keytype);
+
+	/* JK: settings on disk - every hostkey as file in dir */
+	GetCurrentDirectory( (MAX_PATH*2), oldpath);
+	if (SetCurrentDirectory(sshkpath)) {
+		
+		p = snewn(3 * strlen(regname) + 1 + 16, char);
+		packstr(regname, p);
+		strcat(p, keysuffix);
+
+		hFile = CreateFile(p, GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
+		SetCurrentDirectory(oldpath);
+
+		if (hFile != INVALID_HANDLE_VALUE) {
+			/* JK: ok we got it -> read it to otherstr */
+			fileSize = GetFileSize(hFile, NULL);
+			otherstr = snewn(fileSize+1, char);
+			ReadFile(hFile, otherstr, fileSize, &bytesRW, NULL);
+			*(otherstr+fileSize) = '\0';
+
+			compare = strcmp(otherstr, key);
+
+			CloseHandle(hFile);
+			sfree(otherstr);
+			sfree(regname);
+			sfree(p);
+
+			if (compare) { /* key is here, but different */
+				return 2;
+			}
+			else { /* key is here and match */
+				return 0;
+			}
+		}
+		else {
+			/* not found as file -> try registry */
+			sfree(p);
+		}
+	}
+	else {
+		/* JK: there are no hostkeys as files -> try registry -> nothing to do here now */
+	}
+	
+	/* JK: directory/file not found -> try registry */
+	if (RegOpenKey(HKEY_CURRENT_USER, PUTTY_REG_POS "\\SshHostKeys", &rkey) != ERROR_SUCCESS) {
+		return 1;		       /* key does not exist in registry */
+	}
+
+    readlen = len;
+    ret = RegQueryValueEx(rkey, regname, NULL, &type, otherstr, &readlen);
+
+    if (ret != ERROR_SUCCESS && ret != ERROR_MORE_DATA &&
+	!strcmp(keytype, "rsa")) {
+	/*
+	 * Key didn't exist. If the key type is RSA, we'll try
+	 * another trick, which is to look up the _old_ key format
+	 * under just the hostname and translate that.
+	 */
+	char *justhost = regname + 1 + strcspn(regname, ":");
+	char *oldstyle = snewn(len + 10, char);	/* safety margin */
+	readlen = len;
+	ret = RegQueryValueEx(rkey, justhost, NULL, &type,
+			      oldstyle, &readlen);
+
+	if (ret == ERROR_SUCCESS && type == REG_SZ) {
+	    /*
+	     * The old format is two old-style bignums separated by
+	     * a slash. An old-style bignum is made of groups of
+	     * four hex digits: digits are ordered in sensible
+	     * (most to least significant) order within each group,
+	     * but groups are ordered in silly (least to most)
+	     * order within the bignum. The new format is two
+	     * ordinary C-format hex numbers (0xABCDEFG...XYZ, with
+	     * A nonzero except in the special case 0x0, which
+	     * doesn't appear anyway in RSA keys) separated by a
+	     * comma. All hex digits are lowercase in both formats.
+	     */
+	    char *p = otherstr;
+	    char *q = oldstyle;
+	    int i, j;
+
+	    for (i = 0; i < 2; i++) {
+		int ndigits, nwords;
+		*p++ = '0';
+		*p++ = 'x';
+		ndigits = strcspn(q, "/");	/* find / or end of string */
+		nwords = ndigits / 4;
+		/* now trim ndigits to remove leading zeros */
+		while (q[(ndigits - 1) ^ 3] == '0' && ndigits > 1)
+		    ndigits--;
+		/* now move digits over to new string */
+		for (j = 0; j < ndigits; j++)
+		    p[ndigits - 1 - j] = q[j ^ 3];
+		p += ndigits;
+		q += nwords * 4;
+		if (*q) {
+		    q++;	       /* eat the slash */
+		    *p++ = ',';	       /* add a comma */
+		}
+		*p = '\0';	       /* terminate the string */
+	    }
+
+	    /*
+	     * Now _if_ this key matches, we'll enter it in the new
+	     * format. If not, we'll assume something odd went
+	     * wrong, and hyper-cautiously do nothing.
+	     */
+	    if (!strcmp(otherstr, key))
+		RegSetValueEx(rkey, regname, 0, REG_SZ, otherstr,
+			      strlen(otherstr) + 1);
+		/* JK: session is not saved to file - fixme */
+	}
+    }
+
+    compare = strcmp(otherstr, key);
+
+	if (ret == ERROR_MORE_DATA || (ret == ERROR_SUCCESS && type == REG_SZ && compare)) {
+		RegCloseKey(rkey);
+		return 2;		       /* key is different in registry */
+	}
+	else if (ret != ERROR_SUCCESS || type != REG_SZ) {
+		RegCloseKey(rkey);
+		return 1;		       /* key does not exist in registry */
+	}
+	else { /* key matched OK in registry */
+		/* JK: matching key found in registry -> warn user, ask what to do */
+		p = snewn(256, char);
+		userMB = MessageBox(NULL, "The host key is cached in the Windows registry. "
+			"Do you want to move it to a file? \n\n"
+			"Yes \t-> Move to file (and delete from registry)\n"
+			"No \t-> Copy to file (and keep in registry)\n"
+			"Cancel \t-> nothing will be done\n", "Security risk", MB_YESNOCANCEL|MB_ICONWARNING);
+
+		if ((userMB == IDYES) || (userMB == IDNO)) {
+			/* JK: save key to file */
+			if ((hFile = FindFirstFile(sshkpath, &FindFile)) == INVALID_HANDLE_VALUE) {
+				createPath(sshkpath);
+			}
+			FindClose(hFile);
+			SetCurrentDirectory(sshkpath);
+
+			p = snewn(3*strlen(regname) + 1 + 16, char);
+			packstr(regname, p);
+			strcat(p, keysuffix);
+			
+			hFile = CreateFile(p, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+
+			if (hFile == INVALID_HANDLE_VALUE) {
+				errorShow("Unable to create file (key won't be deleted from registry)", p);
+				userMB = IDNO;
+			}
+			else {
+				if (!WriteFile(hFile, key, strlen(key), &bytesRW, NULL)) {
+					errorShow("Unable to save key to file (key won't be deleted from registry)", NULL);
+					userMB = IDNO;
+				}
+				CloseHandle(hFile);
+			}
+		}
+		if (userMB == IDYES) {
+			/* delete from registry */
+			if (RegDeleteValue(rkey, regname) != ERROR_SUCCESS) {
+				errorShow("Unable to delete registry value", regname);
+			}
+		}
+		/* JK: else (Cancel) -> nothing to be done right now */
+		
+		RegCloseKey(rkey);
+
+		sfree(otherstr);
+		sfree(regname);
+		return 0;		       
+	}
+}
+
+void file_store_host_key(const char *hostname, int port,
+		    const char *keytype, const char *key)
+{
+    char *regname = NULL;
+	WIN32_FIND_DATA FindFile;
+    HANDLE hFile = NULL;
+	char* p = NULL;
+	DWORD bytesWritten;
+
+    regname = snewn(3 * (strlen(hostname) + strlen(keytype)) + 15, char);
+    hostkey_regname(regname, hostname, port, keytype);
+
+	/* JK: save hostkey to file in dir */
+	if ((hFile = FindFirstFile(sshkpath, &FindFile)) == INVALID_HANDLE_VALUE) {
+		createPath(sshkpath);
+	}
+	FindClose(hFile);
+	GetCurrentDirectory( (MAX_PATH*2), oldpath);
+	SetCurrentDirectory(sshkpath);
+
+	p = snewn(3*strlen(regname) + 1, char);
+	packstr(regname, p);
+	strcat(p, keysuffix);
+	hFile = CreateFile(p, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE) {
+		errorShow("Unable to create file", p);
+	}
+	else {
+		if (!WriteFile(hFile, key, strlen(key), &bytesWritten, NULL)) {
+			errorShow("Unable to save key to file", NULL);
+		}
+		CloseHandle(hFile);
+	}
+	SetCurrentDirectory(oldpath);
+
+    sfree(p);
+	sfree(regname);
+}
